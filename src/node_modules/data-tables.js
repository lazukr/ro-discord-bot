const cheerio = require('cheerio');

const NOVA_VEND = "nova_vend";
const BY_TEXT = "text";
const MARKET_TABLE = "market-table";
const TABLE = "table";
const DIVINE = "divine";
const DESCRIPTION = "description";

const NEW_HEADERS = Object.freeze({
  QTY: "qty",
  ITEM: "item",
  PRICE: "price",
  ADDPROPS: "property",
  REFINE: "refine",
  LOCATION: "location",
});

const NEW_ABBREVIATION = Object.freeze({
  REFINE: "rfn",
  ADDPROPS: "+props",
});

class DataTable {
  constructor(header, contents) {
    this.header = header;
    this.contents = contents;
  }

  get tableLength() {
    return this.contents.length;
  }

  static rowify($, table, type = TABLE) {
    const data = this._rowify($, table, type);
    return new DataTable(data.header, data.contents); 
  }

  static _getItemName($, id) {
    return $(id).find('div.item-name').text().trim();
  }

  static _rowify($, table, type) {
    const rows = $(table).find('tr');
    const header = {};

    $(rows).find('th').each((i, elem) => {
      const text = $(elem).text().trim();
        header[text] = text;
    });
    const keys = Object.keys(header);
    const contents = [];
    const content = $(rows).find('td').toArray();
    content.reduce((re, va, i, ar) => {
      if (i % keys.length === 0) {
        const curArray = ar.slice(i, i + keys.length);
        const dict = curArray.reduce((re, va, i) => {
          if (header[keys[i]] == "Item" &&
              type == MARKET_TABLE) {
            const tooltip = $(va).find('img')
              .data('tooltipContent');
            const name = this._getItemName($, tooltip);
            const itemID = tooltip.match(/\d+/g)[0];
            re[header[keys[i]]] = `${itemID} - ${name}`;
          } else if (type == DESCRIPTION) {
            re[header[keys[i]]] = $(va).text().trim();
          } else if (header[keys[i]] === "Name" && type === DIVINE) {
            const id = $(va).find('a').attr('href').match(/\d{3,}/g)[0];
            re.Id = id;
            re[header[keys[i]]] = $(va).text().trim();
          } else {
            re[header[keys[i]]] = $(va).text().trim()
              .split("\n")[0];
          }
          return re;
        }, {});
        contents.push(dict);
      }
    }, {});
    return {
      header: type === DIVINE ? {'Id': "Id", ...header} : header,
      contents: contents,
    };
  }

  objectify() {
    return {
      header: this.header,
      contents: this.contents,
    };
  }

  checkColExists(col) {
    return this.header[col] ? true : false;
  }

}; 

class MarketTable extends DataTable {
  constructor(header, contents) {
    super(header, contents);
  }
  
  static rowify($, table, by = "html") {
    const data = super._rowify($, table, by);
    return new MarketTable(data.header, data.contents);
  } 

  strToIntCols(col) {
    if (!super.checkColExists(col)) {
      return;
    }
    this.contents.forEach(tr => {
      tr[col] = parseInt(tr[col].replace(/,|\+/g, ''));
    });  
  }

  intToStrCols(col) {
    if (!super.checkColExists(col)) {
      return;
    }
    this.contents.forEach(tr => {
      tr[col] = tr[col].toLocaleString();
    });
  }
  
  sort(col) {
    this.contents.sort((a, b) => {
      return a[col] - b[col];
    });  
  }

  abbreviate(header, abbreviators) {
    Object.keys(abbreviators).forEach(th => {
      if (this.header[header[th]]) {
        this.header[header[th]] = abbreviators[th];  
      }
    }); 
  }

  locToNavi(header, loc_navi) {
    this.contents.forEach(tr => {
      const locArray = tr[header.LOCATION].trim().split(',');
      tr[header.LOCATION] = locArray[0] == NOVA_VEND ?
        `@sj ${locArray[1]} ${locArray[2]}` :
        `@navi ${locArray[0]} ${locArray[1]}/${locArray[2]}`;
    });
  }
}

class NewMarketTable extends MarketTable {
  constructor(header, contents) {
    super(header, contents);
    this.abbreviate(NEW_HEADERS, NEW_ABBREVIATION);
    this.locToNavi(NEW_HEADERS);
    this.itemParse();
    this.propertyParse();
    this.sort('price');
    this.intToStrCols('qty');
    this.intToStrCols('price');
    this.intToStrCols('refine');
  }

  itemParse() {
    if (!this.contents[0].item) {
      return;
    }

    this.contents.forEach(tr => {
      tr.item = tr.item.match(/\d+.(?=.png)/)[0];
    });
  }

  propertyParse() {
    if (!this.contents[0].property) {
      return;
    }

    this.contents.forEach(tr => {
      tr.property = cheerio(tr.property).text().trim();
    });

  }
}

exports.DataTable = DataTable;
exports.MarketTable = MarketTable;
exports.NewMarketTable = NewMarketTable;
exports.MARKET_TABLE = MARKET_TABLE;
exports.TABLE = TABLE;
exports.DESCRIPTION = DESCRIPTION;
exports.DIVINE = DIVINE;
