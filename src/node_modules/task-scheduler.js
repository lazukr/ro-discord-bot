const scheduler = require('node-schedule');
const uuidv5 = require('uuid/v5');
const uuidv4 = require('uuid/v4');
const moment = require('moment-timezone');
const tf = require('task-factory');

// own
const logger = require('logger.js')("Task Scheduler Module");
const pp = require('pretty-print');
const dt = require('data-tables');
const nvro = require('nova-market-commons');
const taskFactory = require('task-factory');
const objPrint = require('object-printer');
const config = require('../config.json');
const notifier = require('notifier');

moment.locale('en', {
  calendar: {
    lastDay : '[Yesterday at] LT',
    sameDay : '[Today at] LT',
    nextDay : '[Tomorrow at] LT',
    lastWeek : '[on last] dddd [at] LT',
    nextWeek : '[on] dddd [at] LT',
    sameElse : '[on] llll'
  }
});

const USERDB = 'src/userdb';

// scheduler class that handles both the scheduling
// and persist storing of the schedules
class Scheduler {
  constructor(directory) {
    this.storage = require('node-persist');
    this.userdb = this.storage.create();
    this.scheduler = require('node-schedule');
    this.factory = new taskFactory.TaskFactory();
    this.directory = directory;
    this.scheduledJobs = {};
    this.noschedule = false;
  }

  get header() {
    return {
      index: "#",
      scheduled: "Scheduled Time",
      //owner: "Owner",
      message: "Message",
    };
  }

  get autoMarketHeader() {
    return {
      index: "#",
//      scheduled: "Interval (mins)",
      //owner: "Owner",
      itemID: "ItemID",
      filters: "Filtering on",
    };
  }

  async getScheduledJobs(identifier, ownerid = null) {
    logger.info(`Getting ${identifier} items in scheduler...`);
    const list = await this._getMessageOfType(identifier);
    return list.filter(dict => ownerid ? dict.value.ownerid === ownerid : true);
  }

  async init(client) {
    this.client = client;
    this.replyChannel = this.client.channels.get(config.replyChannel);

    await this.storage.init({
      dir: this.directory,
    });

    await this.userdb.init({
      dir: USERDB, 
    });
    await this._initialTaskHandler();
  }

  async _initialTaskHandler() {
    logger.info(`Number of current task ${await this.storage.length()}`);
    const currentDT = new Date();
    await this.storage.forEach(async (data) => {
      logger.debug(`key: ${data.key}.`);

      if (data.value.filters) {
        const filters = data.value.filters;
        if (filters.Price) {
          filters.price = filters.Price;
          delete filters.Price;
        }

        if (filters['Additional Properties']) {
          filters.property = filters['Additional Properties'];
          delete filters['Additional Properties'];
        }
        data.value.filters = filters;
        await this.storage.setItem(data.key, data.value);
      }

      if (data.key == taskFactory.INTERVAL) {
        logger.debug(`interval task`);
        return;
      }
      const task = this.factory.getTask(data.value);
      if (task.type === taskFactory.MSG) {
        if (task.isExpired(currentDT)) {
          logger.info(`Task ${data.key} has already expired on ${task.scheduled}. It will now trigger immediately at ${currentDT}`);
          await this.processTask(data.key, task);
          return;
        }

        await this.queue(data.key, task);
      } 

    });    
    logger.info(`Number of task after startup ${await this.storage.length()}`);
    
    if (this.noschedule) {
      logger.warn('Scheduler was intentionally disabled. Set noschedule=false to enable');
      return;
    }

    const interval = this.scheduler.scheduleJob('interval', '*/1 * * * *', async () => {
      logger.info('Processing automarkets...');
      if (!tf.AutoMarketTask.getPage) {
        logger.warn('Bot is not logged in!');
-       this.replyChannel.send(`Bot is not logged in!. <@${config.ownerid}> please check!`);
        return;
      }

      this._processAutomarkets();
    });
    
    this.scheduledJobs['interval'] = interval;
  }

  async add(props) {
    const task = this.factory.makeTask(props); 
    if (!task) {
      return null;
    }
    await this.storage.setItem(task.uuid, task.job);
    if (task.job.type === taskFactory.MSG) {
      await this.queue(task.uuid, task.job);
    }
    return task.job; 
  }

  async remove(identifier, index, ownerid = null, byid = false) {

    const list = await this.getScheduledJobs(identifier, ownerid);
    //console.log(list);

    // removing by id
    if (byid) {
      const result = list.filter(dict => dict.value.itemID === index);
      const idResultList = await this.getAutoMarketList(1, ownerid, index, true);
      // if there is more than one, we should ask the user to specify which one
      if (result.length > 1) {
        return `Multiple Results exist. Please use ID to remove the ones you want. ${idResultList}`;
      }
      const removeStatus = await this._remove(result[0].key);
      if (!removeStatus.existed) {
        return "Item was not found.";
      }
      return `Item successfully removed. ${idResultList}`;
    }

    if (list.length < index) {
      return "Index selected is larger than the number of items in list.";
    }
    const idResultList = identifier === taskFactory.AUTOMARKET ?
     await this.getAutoMarketList(1, ownerid, index-1, false) :
     await this.getMessageList(1, ownerid, index-1);

    //console.log(list[index-1].key)

    const removeStatus = await this._remove(list[index - 1].key);
    logger.info(removeStatus);
    if (!removeStatus.existed) {
      return "Item was not found.";
    }
    return `Item successfully removed. ${idResultList}`;
  }

  cancelAllJobs() {
    logger.info(`Cancelling all jobs...`);
    const scheduledJobs = Object.keys(this.scheduledJobs);
    scheduledJobs.forEach(key => {
      this._cancelJob(key);
    });    
  }

  _cancelJob(key) {
    if (key in this.scheduledJobs &&
      this.scheduledJobs[key]) {
      this.scheduledJobs[key].cancel();
      delete this.scheduledJobs[key];
      logger.info(`Scheduled jobs: ${JSON.stringify(this.scheduledJobs)}`);
    }
  }

  async _remove(key) {
    this._cancelJob(key);
    const data = await this.storage.getItem(key);
    logger.debug(`Removing item ${key} with data "${data.args}"...`);
    const removeStatus = await this.storage.removeItem(key);
    return removeStatus;
  }

  async clear(identifier, ownerid = null) {
    logger.debug(`Clearing all ${identifier} items...`);
    const list = await this.getScheduledJobs(identifier, ownerid);
    list.forEach(async (task) => {
      await this._remove(task.key);
    });
    logger.info(`Successfully cleared all ${identifier} items for ${ownerid}.`);
  }

  async _getMessageKeysOfType(identifier) {
    const list = await this.storage.keys();
    return list.filter(key => {
      return key.includes(identifier);
    }).sort((a, b) => ('' + a).localeCompare(b));
  }

  async _getMessageOfType(identifier) {
    const list = [];
    await this.storage.forEach(async (task) => {
      if (task.key.includes(identifier)) {
        list.push(task);
      }
    });

    return list
      .sort((a, b) => ('' + a.key).localeCompare(b.key))
      .map(task => {
        //console.log(task.key);
        return {
          key: task.key,
          value: task.value,
        };
      });
  }

  async getMessageList(page, ownerid = null, id= null) {
    const msgList = await this.getScheduledJobs(taskFactory.MSG, ownerid);
    const list = await Promise.all(msgList.map(async (dict, i) => {

      const data = dict.value;
      if (id !== null && id !== i) {
        return undefined;
      }

      const parseDate = Date.parse(data.scheduled);
      //const localized = await this.timeLocalize(data.ownerid, data.scheduled);
      const scheduled = isNaN(data.scheduled) &&
        !isNaN(parseDate) ? 
        await this.timeLocalize(data.ownerid, data.scheduled) :
        data.scheduled;
      return {
        index: (i + 1).toString(),
        message: data.args,
        scheduled: scheduled, 
      };
    }));
  
    const messageTable = {
      name: "Reminders",
      table: new dt.DataTable(this.header, list.filter(entry => entry)),
    };
    const prettyTable = new pp.PrettyTableFactory(messageTable); 
    return prettyTable.getPage(page);
  }

  async _processAutomarkets() {
    const list = await this.getScheduledJobs(taskFactory.AUTOMARKET);
    if (list.length === 0) {
      return;
    }

    let notLoggedIn = false;

    const amResult = await Promise.all(list.map((dict, i) => {
      return new Promise(async (res) => {
        setTimeout(async () => {
          const data = dict.value;
          const result = await nvro.getNewMarketData(data.itemID);
          if (result.error === nvro.ERROR.NO_LOGIN) {
            notLoggedIn = true;
          }
          
          res({result: result, data: data, key: dict.key});
        }, 250 * i);
      });
    }));

    if (notLoggedIn) {
      const channel = this.client.channels.get(config.replyChannel);
      channel.send(`Bear was unable to log in <@${config.ownerid}>! Please check!`);
    }
    
    const filteredResults = amResult
    .map(entry => {
      const { data, result, key } = entry;
      const { 
        channel, 
        ownerid,
        itemID,
        name,
        filters,
        owner,
      } = data;

      // for replacing name in case name was not found.
      let diff = false;
      if (!data.name || data.name === "???") {
        data.name = result.name;
        diff = true;
      }

      if (result.error === nvro.ERROR.BAD_REQUEST) {
        logger.info(`Bad Request. => [${owner}] ${itemID}-${name}: ${JSON.stringify(filters)}`);
        if (diff) {
          return {data: data, key: key};
        }
        return;
      }

      if (result.error === nvro.ERROR.NO_RESULT) {
        if (!data.results || data.results.length === 0) {
          logger.info(`Same. => [${owner}] ${itemID}-${name}: ${JSON.stringify(filters)}`);
          
          // no change
          if (diff) {
            return {data: data, key: key};
          }
          
          return;
        }

        // update data to reflect change
        logger.info(`Empty => [${owner}] ${itemID}-${name}: ${JSON.stringify(filters)}`);
        data.results = '';
        const replyChannel = this.client.channels.get(channel);

        replyChannel.send(`<@${ownerid}>! Bear has message for you.\n\`\`\`${pp.HIGHLIGHT}\n${itemID} - ${name}\n\nNo Results Found :(\n\`\`\``); 
        return {data: data, key: key};
      }

      //console.log(data);
    
      const prettyTable = new pp.PrettyTableFactory(result);
      const newResults = prettyTable.getPage(1, data.filters, true);

      // different results
      if (JSON.stringify(newResults) !== JSON.stringify(data.results)) {
        logger.info(`Change => [${owner}] ${itemID}-${name}: ${JSON.stringify(filters)}`);
        data.results = newResults;
        const replyChannel = this.client.channels.get(channel);
        replyChannel.send(`<@${ownerid}>! Bear has message for you.\n ${newResults}`);
        return {data: data, key: key};
      }

      logger.info(`Same. => [${owner}] ${itemID}-${name}: ${JSON.stringify(filters)}`);

      if (diff) {
        return {data: data, key: key};
      }
    });
    
    filteredResults
      .filter(x => x)
      .forEach(async (entry) => {
        const { data, key } = entry;
        await this.storage.setItem(key, data);
      });
  }

  async _getAutoMarketList(ownerid = null) {
    const list = await this.getScheduledJobs(taskFactory.AUTOMARKET, ownerid);
    if (list.length === 0) {
      return;
    }

    try {
      const amResult = await Promise.all(list.map((dict, i) => {
        return new Promise(async (res) => {
          setTimeout(async () => {
            const data = dict.value;
            const result = await nvro.getNewMarketData(data.itemID);
            if (result.error != nvro.ERROR.NONE) {
              res(null);
            }
            res({...result, filters: data.filters});
          }, 250 * i);
        });
      }));

      const filteredResults = amResult
        .filter(x => x != null)
        .map((data, i) => {
          //console.log(data);
          data.table.intToStrCols(nvro.HEADERS.QTY);
          data.table.intToStrCols(nvro.HEADERS.PRICE);
          data.table.intToStrCols(nvro.HEADERS.REFINE);
          const prettyTable = new pp.PrettyTableFactory(data);
          return prettyTable.hasResults(data.filters) ?  
            prettyTable.getPage(1, data.filters, true) :
            null;
        });
      const replyResults = filteredResults
        .filter(x => x != null);
      //console.log(replyResults);
      return replyResults;
    } catch(e) {
      logger.error(e);
      notifier.send(e);
    }
  }

  async getAutoMarketList(page, ownerid = null, filterid = null, byid = false) {
    const automarketList = await this.getScheduledJobs(taskFactory.AUTOMARKET, ownerid);

    const list = await Promise.all(automarketList.map(async (dict, i) => {
      const data = dict.value;
      //console.log(data);
      if (filterid !== null && byid && data.itemID !== filterid) {
        return undefined;
      }

      if (filterid !== null && !byid && i !== filterid) {
        return undefined;
      }
    
      const filterString = data.filters[nvro.HEADERS.ADDPROPS];
      if (data.filters[nvro.HEADERS.PRICE]) {
        const price = `${data.filters[nvro.HEADERS.PRICE].toLocaleString()}z`;
        filterString.unshift(price);
      }

      const refine = data.filters[nvro.HEADERS.REFINE];
      if (refine) {
        filterString.unshift(refine);
      }
      //const interval = await this.getCronInterval();
      //const scheduled = `Every ${interval} minute${interval == 1 ? "" : "s"}`;
      
      const name = data.itemID === data.name ? data.itemID.toString() : `${data.itemID} - ${data.name}`;
      
      const returnObj = {
        index: (i + 1).toString(),
        itemID: name,
        //scheduled: scheduled,
        filters: filterString.join(', '),
      };

      if (!ownerid) {
        returnObj.owner = data.owner;
      }
      return returnObj;

    }));

    const header = this.autoMarketHeader;
    if (!ownerid) {
      header.owner = "Owner";
    }

    const automarketTable = {
      name: "Auto Market",
      table: new dt.DataTable(header, list.filter(entry => entry)),
    };
    
    const prettyTable = new pp.PrettyTableFactory(automarketTable);
    return prettyTable.getPage(page, {}, filterid === null ? false : true);
  }

  async processTask(taskid, task) {
    logger.info(`Processing task...\n${taskid}`); 
    const channel = this.client.channels.get(task.channel);
    const result = await task.process(channel);
    
    if (result) {
      await this.storage.setItem(taskid, result);
    }
    
    if (task.type == taskFactory.MSG) {
      await this._remove(taskid);
      this._cancelJob(taskid);
    }
  }

  async queue(taskid, task) {
    logger.info(`Queuing task: ${taskid}`);
    const jobName = `${taskid}@${new Date()}`;
    const job = this.scheduler.scheduleJob(jobName, task.scheduled, async function() {
      await this.processTask(taskid, task); 
    }.bind(this));
    this.scheduledJobs[taskid] = job;
  }

  async timeLocalize(userid, scheduled) {
    const timezone = await this.userdb.getItem(userid);
    return moment(scheduled).tz(timezone).calendar();
  }
};

module.exports = Scheduler;
