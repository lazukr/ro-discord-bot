// all scraping stuff
const rp = require('request-promise').defaults({jar: true});
const cheerio = require('cheerio');
const fs = require('fs');
const hooman = require('hooman');

const op = require('object-printer');
const config = require('../config.json');
const tf = require('task-factory');
const logger = require('logger.js')("Scraping module");
const sessionConfig = require('../../session.json');
const notifier = require('notifier');

const LINK = 'https://www.novaragnarok.com';
const DADJOKE_URI = 'https://icanhazdadjoke.com/';
const MINUTE = 1000 * 60;

const MARKET_LINK = 'https://www.novaragnarok.com/data/cache/ajax/item_*.json?cache=0';

const validCookieToken = 'fluxSessionData';

let serverDown = false;

async function login(captcha) {
  const options = {
    searchParams: {
      module: 'account',
      action: 'login',
    },
    form: {
      username: config.novaUsername,
      password: config.novaPassword,
      server: 'NovaRO',
      'g-recaptcha-response': captcha,
    },
  };

  try {
    const { request } = await hooman.post(LINK, options);
    const cookie = request.options.headers.cookie;

    if (!cookie.includes(validCookieToken)) {
      logger.error(`Failed to login.`);
      return 0;
    }
    logger.info(`Login successful!`);
    tf.AutoMarketTask.getPage = getPageWithCookie(cookie);
    return 1;

  } catch (error) {
    logger.error(`An error occurred with Nova login: ${error}.`);
    notifier.send(`An error has occurred with Nova login: ${error}.`);
    return 0;
  }
}

const getPageWithCookie = (cookie) => {
  return async (url, qs = {}) => {
    const options = {
      searchParams: qs,
      headers: {
        cookie: cookie,
      },
    };

    try {
      const { body, statusCode } = await hooman.get(url, options);
      return {
        $: cheerio.load(body),
        statusCode: statusCode,
      };
    } catch (error) {
      logger.error(`An error has occurred on request. Status: ${error}`);

      notifier.send(error);
      if (error.response.statusCode === 404) {
        return;
      }

      notifier.send(`An error has occurred on request. Status: ${error}`);
    }
  };
};

async function getItemMarketData(itemID) {
  try {
    const link = `${MARKET_LINK.replace("*", itemID)}`;
    //onsole.log(link);
    const { body } = await hooman.get(link, {
        responseType: 'json',
    });
    const data = body.data;
    //logger.info(headers["cf-cache-status"]);
    //notifier.send(data);
    /*
    const report_res = data
      .map(i => i.orders)
      .sort((a, b) => a.price - b.price);
    notifier.send(`${link} \n ${JSON.stringify(report_res)}`);
    */
    return data;
  } catch(error) {
    notifier.send(error);
    if (error.response.statusCode === 404 ||
        error.response.statusCode > 500) {
      return [];
    }

    logger.error(`An error has occurred on request. Status ${error}`);
    notifier.send(`An error has occurred on request. Status: ${error}`);
  }
}

async function getDadJoke() {
  const options = {
    method: 'GET',
    uri: DADJOKE_URI,
    headers: {
      'Accept': 'application/json',
      'User-Agent': 'request (https://github.com/lazukr/ro-discord-bot)',
    },
    transform: (body) => {
      return JSON.parse(body);
    }
  };

  return rp(options)
    .then(res => {
      return res;
    })
    .catch(err => {
      logger.error(`An error has occurred on ${DADJOKE_URI}: ${err}`);
    });
}

exports.login = login;
exports.getDadJoke = getDadJoke;
exports.getItemMarketData = getItemMarketData;
