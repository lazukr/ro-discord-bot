const logger = require('logger.js')("nova-market module");
const tf = require('task-factory');
const sc = require('scrape-commons');
const dt = require('data-tables');
const notifier = require('notifier');

const MARKET_URL = 'https://www.novaragnarok.com';
const UNKNOWN = "Unknown";
const NOVA_VEND = "nova_vend";
const HG_PREVIEW = "Headgear Preview";

const storage = require('node-persist');
const itemStorage = storage.create();
itemStorage.init({
  dir: 'data/items',
});

const REFINE_FINDER = /^(<)?\+\d{1,2}$/;
const PAGE_FINDER = /^p\d{1,2}$/;
const ZENY_FINDER = /^(\d{1,3}(.\d+)?[kmb]|\d+)$/;
const QUOTE_FINDER = /^\".*\"$/;

const ERROR = Object.freeze({
  NONE: 0,
  NO_LOGIN: 1,
  NO_RESULT: 2,
  BAD_REQUEST: 3,
});

const HEADER_ABBRV = Object.freeze({
  ADDPROPS: "+ Props",
  REFINE: "Rfn",
});

const HEADERS = Object.freeze({
  QTY: "qty",
  ITEM: "item",
  PRICE: "price",
  ADDPROPS: "property",
  REFINE: "refine",
  LOCATION: "location",
});

const LOC_NAVI = Object.freeze({
  NOVA: "@sj",
  OTHER: "@navi",
});

async function getPopulation() {
  if (!tf.AutoMarketTask.getPage) {
    return;
  }
  try {
    const { $ } = await tf.AutoMarketTask.getPage(MARKET_URL, {});
    const pop = $('.online-status').text().trim().replace(/^\D+/g, '');
    console.log(pop);
    return pop;
  } catch(e) {
    console.log('no pops for you', e);
    notifier.send('no pops for you');
  }
}


async function getSearchData(name) {
  const qs = {
    "module": "item",
    "action": "index",
    "name": name,
  };

  if (!tf.AutoMarketTask.getPage) {
    return {
      name: name,
      error: ERROR.NO_LOGIN,
    }
  }

  const { $ } = await tf.AutoMarketTask.getPage(MARKET_URL, qs);
  const search = getSearchTable($);
  
  if (!search) {
    return {
      name: name,
      error: ERROR.NO_RESULT,
    };
  }

  return {
    name: name,
    table: search,
    error: ERROR.NONE,
  };
}

async function getItemData(itemID) {
  const qs = {
    "module": "vending",
    "action": "view",
    "id": itemID,
  };

  if (!tf.AutoMarketTask.getPage) {
    return {
      error: ERROR.NO_LOGIN,
    };
  }

  const { $ } = await tf.AutoMarketTask.getPage(MARKET_URL, qs);
  const itemInfoTable = getItemTable($, 0);
  const temp = getItemTable($, 1);
 
  const title = $(temp).children().first().children().first().text().trim();
  const itemDescription = title === HG_PREVIEW ? getItemTable($, 2) : temp;
  const itemMobDrops = title === HG_PREVIEW ? getItemTable($, 3) : getItemTable($, 2);
  
  let preview;

  if (title === HG_PREVIEW) {
    const res = temp;
    preview = $(res).find('img').eq(1).attr('src');
  }

  // removes image tr 
  $(itemInfoTable).children().first().children().first().remove();
  // removes last tr from item drops 
  $(itemMobDrops).children().first().children().last().remove();

  $(itemMobDrops).find('th').each((i, item) => {
    item.tagName = 'td';
  });
  
  const dropTitle = "<tr><th>Id</th><th>Name</th><th>Drop Rate</th></tr>";
  $(itemMobDrops).children().first().children().first().replaceWith(dropTitle);

  const info = dt.DataTable.rowify($, itemInfoTable, dt.MARKET_TABLE);
  const description = dt.DataTable.rowify($, itemDescription, dt.DESCRIPTION);
  const drops = dt.DataTable.rowify($, itemMobDrops);  

  drops.contents = drops.contents.slice(0, 25);

  const icon = `${MARKET_URL}/data/items/icons2/${itemID}.png`;
  const image = `${MARKET_URL}/data/items/images2/${itemID}.png`;
  const url = `${MARKET_URL}/?module=vending&action=view&id=${itemID}`;

  return {
    info: info,
    description: description,
    drops: drops,
    icon: icon,
    image: image,
    url: url,
    preview: preview,
  };  
}

async function getNewMarketData(itemID) {
  const qs = {
    "module": "vending",
    "action": "item",
    "id": itemID,
  };

  const name = await getItemName(itemID);
  const data = await sc.getItemMarketData(itemID);
  // no result case
  if (data.length === 0) {
    return {
      id: itemID,
      name: name,
      error: ERROR.NO_RESULT,
    };
  }

  const items = data.map(i => i.items);
  const orders = data.map(i => i.orders);
  const itemHeaders = Object.getOwnPropertyNames(items[0]);
  const orderHeaders = Object.getOwnPropertyNames(orders[0]);
  const afterPropertyResults = orderHeaders.includes('property') ?
    orders.map((item, index) => {
      item.property = items[index].property;
      return item;
    }) :
    orders;

  const afterRefineResults = itemHeaders.includes('refine') ?
    afterPropertyResults :
    afterPropertyResults.map(item => {
      delete item.refine;
      return item;
    });

  const results = afterRefineResults;
  const headers = Object.getOwnPropertyNames(results[0]).reverse().reduce((acc, cur) => {
      acc[cur] = cur;
      return acc;
      }, {});

  const mt = new dt.NewMarketTable(headers, results);

  return {
    id: itemID,
    name: name,
    table: mt,
    error: ERROR.NONE,
  };
}


async function getLiveMarketData(itemID) {
  // grab market info from page itself
  const qs = {
    "module": "vending",
    "action": "item",
    "id": itemID,
  };

  if (!tf.AutoMarketTask.getPage) {
    return {
      id: itemID,
      name: '???',
      error: ERROR.NO_LOGIN,
    }
  }

  const { $, statusCode } = await tf.AutoMarketTask.getPage(MARKET_URL, qs);

  if (statusCode !== 200) {
    logger.warn(`bad Requests received ${statusCode}`);
    return {
      id: itemID,
      name: name,
      error: BAD_REQUEST,
    };
  }

  const name = getItemNameFromId($);
     
  const loginBtn = $('input[type="submit"]').get(1).attribs.value;
 
  if (loginBtn === 'Log In') {
    tf.getPage = null;
    return {
      id: itemID,
      name: name,
      error: ERROR.NO_LOGIN,
    };
  }
    
  const market = getMarketTable($);
  
  // no result case
  if (!market) {
    return {
      id: itemID,
      name: name,
      error: ERROR.NO_RESULT,
    };
  }

  return {
    id: itemID,
    name: name,
    table: market,
    error: ERROR.NONE,
  };
}

function getItemTable($, num) {
  const table = $('.vertical-table').get(num);
  if (!table) {
    return null;
  }
  return table;
}


function getTable($) {
  const table = $('#itemtable').get(0);
  if (!table) {
    return null;
  }
  return table;
}

function getSearchTable($) {
  const table = getTable($);

  if (!table) {
    return null;
  }

  const search = dt.DataTable.rowify($, table, dt.MARKET_TABLE);
  return search;
}


function getMarketTable($) {
  // get table, headers and all rows
  const table = getTable($);
  // if table doesn't exist, then there are no results
  if (!table) {
    const noResults = $('div:contains("No items found. Go back.")').text(); 
    
    if (noResults) {
      logger.info("No items found.");
    } else {
      logger.info("Some other page is showing.");
    }
    return null;
  }

  // get the rowified MarketTable object
  const market = dt.MarketTable.rowify($, table, dt.MARKET_TABLE); 
  // market related data manipulation
  market.abbreviate(HEADERS, HEADER_ABBRV);
  market.locToNavi(HEADERS, LOC_NAVI);
  market.strToIntCols(HEADERS.QTY);
  market.strToIntCols(HEADERS.PRICE);
  market.strToIntCols(HEADERS.REFINE);
  market.sort(HEADERS.PRICE);
  return market;
}

// gets the name of the item from the itemID
function getItemNameFromId($) {
  const header = $('h2').get(0);
  return $(header).find('a').text().trim();
}

function getFilters(args) {
  
  const refine = args.find(arg => {
    return arg.match(REFINE_FINDER);
  });

  const page = args.find(arg => {
    return arg.match(PAGE_FINDER);
  });

  const zeny = args.find(arg => {
    return arg.match(ZENY_FINDER);
  });

  if (zeny) {
    args = args.filter(arg => arg != zeny);
  }

  if (refine) {
    args = args.filter(arg => arg != refine);
  }

  if (page) {
    args = args.filter(arg => arg != page);
  }

  const price = zeny ? parseFloat(zeny) * (zeny.includes('k') ? 
    1000 : zeny.includes('m') ?
    1000000 : zeny.includes('b') ?
    1000000000 : 1) : undefined;

  const filters = {};
  filters[HEADERS.PRICE] = price; 
  filters[HEADERS.REFINE] = refine;
  filters[HEADERS.ADDPROPS] = args.map(arg => {
    // assumes that filters meant to apply to the same property 
    // comes in one string without space, separated by commas
    // e.g. a,b => look for a AND b within a property
    const res = arg.trim().split(',').map(x => x.trim().toLowerCase());
    return res; 
  });
  //console.log(filters[HEADERS.ADDPROPS]);

  filters.page = page ? parseInt(page.slice(1)) : 1;
  return filters;
}

async function getItemName(itemID) {
  const qs = {
    "module": "vending",
    "action": "item",
    "id": itemID,
  };

  let name = '???';
  const storedName = await itemStorage.getItem(`${itemID}`);
  if (!storedName) {
    if (tf.AutoMarketTask.getPage) {
      const { $, statusCode } = await tf.AutoMarketTask.getPage(MARKET_URL, qs);
      if (statusCode === 200) {
        name = getItemNameFromId($);

        if (name) {
          itemStorage.setItem(`${itemID}`, name);
        }
      }
    }
  } else {
    name = storedName;
  }
  return name; 
}

exports.getPopulation = getPopulation;
exports.getLiveMarketData = getLiveMarketData;
exports.getSearchData = getSearchData;
exports.getItemData = getItemData;
exports.getFilters = getFilters;
exports.getMarketTable = getMarketTable;
exports.getNewMarketData = getNewMarketData;
exports.getItemName = getItemName;
exports.ERROR = ERROR;
exports.HEADERS = HEADERS;
